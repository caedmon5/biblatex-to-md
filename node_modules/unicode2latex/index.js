"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Transform = exports.replace_macro_spacers = exports.combining = exports.latex2unicode = exports.minimal = exports.bibtex = exports.biblatex = void 0;
exports.biblatex = require('./tables/biblatex.json');
exports.bibtex = require('./tables/bibtex.json');
exports.minimal = require('./tables/minimal.json');
const maps = { biblatex: exports.biblatex, bibtex: exports.bibtex, minimal: exports.minimal };
exports.latex2unicode = require('./tables/latex2unicode.json');
function permutations(str) {
    if (str.length === 0)
        return [];
    if (str.length === 1)
        return [str];
    const result = [];
    for (let i = 0; i < str.length; i++) {
        const firstChar = str[i];
        const remainingChars = str.slice(0, i) + str.slice(i + 1);
        const remainingPermutations = permutations(remainingChars);
        for (let j = 0; j < remainingPermutations.length; j++) {
            result.push(firstChar + remainingPermutations[j]);
        }
    }
    return result;
}
exports.combining = require('./tables/combining.json');
const combining_re = new RegExp(exports.combining.regex);
function replace_macro_spacers(latex) {
    return latex.replace(/\0(\s)/g, '{}$1').replace(/\0([^;.,!?${}_^\\/])/g, ' $1').replace(/\0/g, '');
}
exports.replace_macro_spacers = replace_macro_spacers;
const switchMode = {
    math: 'text',
    text: 'math',
};
const re = /(i\uFE20a\uFE21)|([^\u0300-\u036F][\u0300-\u036F]+)|([\uD800-\uDBFF][\uDC00-\uDFFF])|(.)/g;
class Transform {
    constructor(mode, options = {}) {
        let map = Object.assign({}, maps[mode].base);
        const packages = maps[mode].package;
        for (const pkg of (options.packages || []).map(p => packages[p]).filter(p => p)) {
            map = Object.assign(Object.assign({}, map), pkg);
        }
        for (const mode of ['text', 'math']) {
            if (!(mode in options))
                continue;
            for (const c of options[mode]) {
                if (mode in map[c])
                    map[c] = { [mode]: map[c][mode] };
            }
        }
        for (const c of (options.ascii || '')) {
            if (exports.bibtex.base[c])
                map[c] = exports.bibtex.base[c];
        }
        if (options.charmap) {
            for (const [u, t] of Object.entries(options.charmap)) {
                map[u.normalize('NFC')] = map[u.normalize('NFD')] = t;
            }
        }
        this.mode = mode;
        this.map = map;
    }
    tolatex(text, options = {}) {
        const { bracemath, preservemacrospacers, packages } = Object.assign({ bracemath: false, preservemacrospacers: false, packages: new Set }, options);
        let mode = 'text';
        let braced = 0;
        const switchTo = {
            math: (bracemath ? '{$' : '$'),
            text: (bracemath ? '$}' : '$'),
        };
        let mapped;
        let switched;
        let m;
        let cd;
        let latex = '';
        text.normalize('NFD').replace(re, (match, tie, cdpair, pair, single) => {
            mapped = null;
            if (tie && !this.map[tie]) {
                mapped = { text: 'ia' };
            }
            else {
                mapped = this.map[tie] || this.map[pair] || this.map[single] || this.map[cdpair];
            }
            if (!mapped && this.mode !== 'minimal' && cdpair) {
                let char = cdpair[0];
                let cdmode = '';
                cdpair = cdpair.substr(1).replace(combining_re, cdc => {
                    cd = exports.combining.tolatex[permutations(cdc).find(p => exports.combining.tolatex[p])];
                    if (!cd)
                        return cdc;
                    if (!cdmode) {
                        cdmode = cd.mode;
                        char = (this.map[char] || { text: char, math: char })[cdmode];
                    }
                    if (cdmode !== cd.mode)
                        return cdc;
                    const cmd = cd.macro.match(/[a-z]/i);
                    if (this.mode === 'bibtex' && cd.mode === 'text') {
                        char = `{\\${cd.macro}${cmd ? ' ' : ''}${char}}`;
                    }
                    else if (cmd && char.length === 1) {
                        char = `\\${cd.macro} ${char}`;
                    }
                    else if (cmd) {
                        char = `\\${cd.macro}{${char}}`;
                    }
                    else {
                        char = `\\${cd.macro}${char}`;
                    }
                    return '';
                });
                if (!cdpair)
                    mapped = { [cdmode]: char };
            }
            if (!mapped)
                mapped = { text: match };
            if (!mapped[mode]) {
                mode = switchMode[mode];
                latex += switchTo[mode];
                switched = true;
            }
            else {
                switched = false;
            }
            switch (mapped[mode]) {
                case '\\{':
                    braced += 1;
                    break;
                case '\\}':
                    braced -= 1;
                    break;
            }
            if (braced < 0) {
                latex += '\\vphantom\\{';
                braced = 0;
            }
            if (switched && mode === 'text' && (m = latex.match(/([\^_])\{(.)\}(\$\}?)$/))) {
                latex = latex.slice(0, latex.length - m[0].length) + m[1] + m[2] + m[3];
            }
            latex += mapped[mode];
            if (mapped.macrospacer)
                latex += '\0';
            if (!switched && mode === 'math' && (m = latex.match(/(([\^_])\{[^{}]+)\}\2{(.\})$/))) {
                latex = latex.slice(0, latex.length - m[0].length) + m[1] + m[3];
            }
            if (mapped.alt) {
                for (const pkg of mapped.alt) {
                    packages.add(pkg);
                }
            }
            return match;
        });
        switch (braced) {
            case 0:
                break;
            case 1:
                latex += '\\vphantom\\}';
                break;
            default:
                latex += `\\vphantom{${'\\}'.repeat(braced)}}`;
                break;
        }
        if (mode === 'math')
            latex += switchTo.text;
        if (!preservemacrospacers)
            latex = replace_macro_spacers(latex);
        return latex.normalize('NFC');
    }
}
exports.Transform = Transform;
