"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.English = exports.FieldMode = exports.tokenize = exports.toSentenceCase = void 0;
exports.parse = parse;
exports.parseAsync = parseAsync;
const unified_latex_util_replace_1 = require("@unified-latex/unified-latex-util-replace");
const unified_latex_util_pegjs_1 = require("@unified-latex/unified-latex-util-pegjs");
const unified_latex_util_visit_1 = require("@unified-latex/unified-latex-util-visit");
const unified_latex_util_print_raw_1 = require("@unified-latex/unified-latex-util-print-raw");
const unicode2latex_1 = require("unicode2latex");
const bibtex = __importStar(require("./verbatim"));
const JabRef = __importStar(require("./jabref"));
const sentence_case_1 = require("./sentence-case");
var sentence_case_2 = require("./sentence-case");
Object.defineProperty(exports, "toSentenceCase", { enumerable: true, get: function () { return sentence_case_2.toSentenceCase; } });
const tokenizer_1 = require("./tokenizer");
var tokenizer_2 = require("./tokenizer");
Object.defineProperty(exports, "tokenize", { enumerable: true, get: function () { return tokenizer_2.tokenize; } });
const yield_1 = require("./yield");
const crossref_json_1 = __importDefault(require("./crossref.json"));
const fields_json_1 = __importDefault(require("./fields.json"));
const merge_1 = require("./merge");
function latexMode(node) {
    return node._renderInfo.mode;
}
function latex2unicode(tex, node) {
    const text = unicode2latex_1.latex2unicode[tex];
    if (typeof text === 'string')
        return text;
    return text && text[latexMode(node)];
}
const open = {};
const close = {};
for (const tag of ['i', 'b', 'sc', 'nc', 'ncx', 'br', 'p', 'li', 'code']) {
    open[tag] = `\x0E${tag}\x0F`;
    close[tag] = `\x0E/${tag}\x0F`;
}
const collapsable = /\x0E\/([a-z]+)\x0F(\s*)\x0E\1\x0F/ig;
const Month = {
    jan: '1',
    january: '1',
    feb: '2',
    february: '2',
    mar: '3',
    march: '3',
    apr: '4',
    april: '4',
    may: '5',
    jun: '6',
    june: '6',
    jul: '7',
    july: '7',
    aug: '8',
    august: '8',
    sep: '9',
    september: '9',
    oct: '10',
    october: '10',
    nov: '11',
    november: '11',
    dec: '12',
    december: '12',
};
exports.FieldMode = {
    creatorlist: [
        'author',
        'bookauthor',
        'collaborator',
        'commentator',
        'director',
        'editor',
        'editora',
        'editorb',
        'editors',
        'holder',
        'scriptwriter',
        'translator',
    ],
    title: [
        'title',
        'subtitle',
        'series',
        'shorttitle',
        'booktitle',
        // 'type',
        'origtitle',
        'maintitle',
        'eventtitle',
    ],
    verbatim: [
        'doi',
        'eprint',
        'file',
        'files',
        'pdf',
        'groups', // jabref unilaterally decided to make this non-standard field verbatim
        'ids',
        'url',
        'verba',
        'verbb',
        'verbc',
        /^keywords([+]duplicate-\d+)?$/,
        /^citeulike-linkout-[0-9]+$/,
        /^bdsk-url-[0-9]+$/,
    ],
    richtext: [
        'annotation',
        'comment',
        'annote',
        'review',
        'notes',
        'note',
    ],
    literallist: [
        'institution',
        'publisher',
        'origpublisher',
        'organization',
        'location',
        'origlocation',
    ],
};
exports.English = [
    '',
    'american',
    'british',
    'canadian',
    'english',
    'australian',
    'newzealand',
    'usenglish',
    'ukenglish',
    'en',
    'eng',
    'en-au',
    'en-bz',
    'en-ca',
    'en-cb',
    'en-gb',
    'en-ie',
    'en-jm',
    'en-nz',
    'en-ph',
    'en-tt',
    'en-us',
    'en-za',
    'en-zw',
    'anglais', // don't do this people
];
const FieldAction = {
    removeOuterBraces: [
        'doi',
        // 'publisher',
        // 'location',
    ],
    parseInt: [
        'year',
        'month',
    ],
    noCrossRef: [
        'file',
    ],
};
const narguments = {
    advance: 1,
    ElsevierGlyph: 1,
    bar: 1,
    bibcyr: 1,
    bibstring: 1,
    chsf: 1,
    cite: 1,
    citeauthor: 1,
    cyrchar: 1,
    ding: 1,
    emph: 1,
    enquote: 1,
    frac: 2,
    hbox: 1,
    href: 2,
    hskip: 1,
    hspace: 1,
    ht: 1,
    mathrm: 1,
    mbox: 1,
    mkbibbold: 1,
    mkbibemph: 1,
    mkbibitalic: 1,
    mkbibquote: 1,
    newcommand: 2,
    noopsort: 1,
    ocirc: 1,
    overline: 1,
    ProvideTextCommandDefault: 2,
    rlap: 1,
    sb: 1,
    section: 1,
    sp: 1,
    subsection: 1,
    subsubsection: 1,
    subsubsubsection: 1,
    t: 1,
    textbf: 1,
    textcite: 1,
    textit: 1,
    textrm: 1,
    textsc: 1,
    textsl: 1,
    textsubscript: 1,
    textsuperscript: 1,
    texttt: 1,
    textup: 1,
    url: 1,
    vphantom: 1,
    vspace: 1,
    wd: 1,
    // math
    'math\t_': 1,
    'math\t^': 1,
};
for (const m in unicode2latex_1.combining.tounicode) { // eslint-disable-line guard-for-in
    narguments[m] = 1;
}
/*
async function* asyncGenerator<T>(array: T[]): AsyncGenerator<T, void, unknown> {
  for (const item of array) {
    yield await Promise.resolve(item)
  }
}
*/
class BibTeXParser {
    constructor() {
        this.newcommands = {};
        this.unhandled = new Set;
    }
    split(ast, sep, split) {
        const roots = [];
        const nodes = [...ast.content];
        const types = nodes.map(node => {
            if (node.type === 'whitespace')
                return ' ';
            if (node.type === 'string' && node.content.match(sep))
                return '&';
            return '.';
        }).join('');
        types.split(split).forEach((match, i) => {
            const content = match.length ? nodes.splice(0, match.length) : [];
            if ((i % 2) === 0)
                roots.push({ type: 'root', content });
        });
        return roots;
    }
    trimCreator(cr) {
        // trims strings but coincidentally removes undefined fields
        // eslint-disable-next-line @typescript-eslint/no-unsafe-return
        return JSON.parse(JSON.stringify(cr, (k, v) => typeof v === 'string' ? (v.trim() || undefined) : v));
    }
    parseCreator(ast) {
        if (ast.content.length === 1 && ast.content[0].type === 'group')
            return this.trimCreator({ name: this.stringify(ast, { mode: 'creatorlist' }) });
        const { parts, extended } = this.commaSeparatedCreator(ast);
        if (extended) {
            const name = {};
            for (const [attr, value] of Object.entries(extended)) {
                const rendered = this.stringify(value, { mode: 'creatorlist' }).trim();
                switch (attr) {
                    case '':
                        break;
                    case 'given':
                        name.firstName = rendered;
                        break;
                    case 'family':
                        name.lastName = rendered;
                        break;
                    case 'given-i':
                        name.initial = rendered;
                        break;
                    case 'useprefix':
                    case 'juniorcomma':
                        name[attr] = rendered.toLowerCase() === 'true';
                        break;
                    default:
                        name[attr] = rendered;
                        break;
                }
            }
            return this.trimCreator(name);
        }
        else if (parts.length) {
            const nameparts = parts.map((part) => this.stringify(part, { mode: 'creatorlist' }).trim());
            if (nameparts.length === 3 && nameparts[2] === '')
                nameparts.pop();
            if (nameparts.length > 3) {
                const key = this.current.key ? `@${this.current.key}: ` : '';
                this.bib.errors.push({
                    error: `${key}unexpected ${nameparts.length}-part name "${nameparts.join(', ')}", dropping "${nameparts.slice(3).join(', ')}"`,
                    input: nameparts.join(', '),
                });
            }
            let [lastName, suffix, firstName] = (nameparts.length === 2)
                ? [nameparts[0], undefined, nameparts[1]]
                // > 3 parts are invalid and are dropped
                : nameparts.slice(0, 3);
            let prefix;
            const m = lastName.match(/^([a-z'. ]+) (.+)/);
            if (m) {
                prefix = m[1];
                lastName = m[2];
            }
            return this.trimCreator({
                lastName,
                firstName,
                prefix,
                suffix,
            });
        }
        else { // first-last mode
            const nameparts = this.split(ast, /^$/, /( )/).map(part => this.stringify(part, { mode: 'creatorlist' })).filter(n => n);
            if (nameparts.length === 1)
                return this.trimCreator({ lastName: nameparts[0] });
            const prefix = nameparts.findIndex(n => n.match(/^[a-z]/));
            const postfix = prefix <= 0 ? -1 : nameparts.findIndex((n, i) => i > prefix && !n.match(/^[a-z]/));
            if (postfix === -1) {
                const lastName = nameparts.pop();
                return this.trimCreator({ lastName, firstName: nameparts.join(' ') });
            }
            return this.trimCreator({
                firstName: nameparts.slice(0, prefix).join(' '),
                prefix: nameparts.slice(prefix, postfix).join(' '),
                lastName: nameparts.slice(postfix).join(' '),
            });
        }
    }
    ligature(nodes) {
        if (latexMode(nodes[0]) !== 'text')
            return null;
        const max = 3;
        const slice = nodes.slice(0, max);
        const type = slice.map(n => n.type === 'string' ? 's' : ' ').join('');
        if (type[0] !== 's')
            return null;
        const content = slice.map(n => n.type === 'string' ? n.content : '');
        let latex;
        while (content.length) {
            if (type.startsWith('s'.repeat(content.length)) && (latex = latex2unicode(content.join(''), slice[0]))) {
                try {
                    return { type: 'string', content: latex, _renderInfo: {} };
                }
                finally {
                    nodes.splice(0, content.length);
                }
            }
            content.pop();
        }
        return null;
    }
    wraparg(node, macro) {
        if (macro.content.match(/^(itshape|textsl|textit|emph|mkbibemph)$/))
            node._renderInfo.emph = true;
        if (macro.content.match(/^(textbf|mkbibbold|bfseries)$/))
            node._renderInfo.bold = true;
        if (macro.content.match(/^(textsc)$/))
            node._renderInfo.smallCaps = true;
        if (macro.content.match(/^(texttt)$/))
            node._renderInfo.code = true;
        return { type: 'argument', content: [node], openMark: '', closeMark: '', _renderInfo: { mode: node._renderInfo.mode } };
    }
    argtogroup(node) {
        if (node.content.length === 1 && node.content[0].type === 'group')
            return node.content[0];
        return { type: 'group', content: node.content };
    }
    argument(nodes, macro) {
        if (!nodes.length)
            return null;
        if (nodes[0].type === 'whitespace')
            nodes.shift();
        if (!nodes.length)
            return null;
        if (nodes[0].type === 'string') {
            const char = nodes[0].content[0];
            nodes[0].content = nodes[0].content.substr(1);
            const arg = Object.assign(Object.assign({}, nodes[0]), { content: char });
            if (!nodes[0].content)
                nodes.shift();
            return this.wraparg(arg, macro);
        }
        return this.wraparg(nodes.shift(), macro);
    }
    unsupported(node) {
        var _a;
        const tex = (0, unified_latex_util_print_raw_1.printRaw)(node);
        if (this.fallback)
            return (_a = this.fallback(node, tex, this.current)) !== null && _a !== void 0 ? _a : '';
        let id;
        switch (node.type) {
            case 'macro':
                id = `${node.type}.${node.content}`;
                if (!this.unhandled.has(id)) {
                    this.unhandled.add(id);
                    this.bib.errors.push({ error: `unhandled ${node.type} ${(0, unified_latex_util_print_raw_1.printRaw)(node)}`, input: (0, unified_latex_util_print_raw_1.printRaw)(node) });
                }
                break;
            case 'environment':
                id = `${node.type}.${node.env}`;
                if (!this.unhandled.has(id)) {
                    this.unhandled.add(id);
                    this.bib.errors.push({ error: `unhandled ${node.type} ${node.env} (${(0, unified_latex_util_print_raw_1.printRaw)(node)})`, input: (0, unified_latex_util_print_raw_1.printRaw)(node) });
                }
                break;
            default:
                this.bib.errors.push({ error: `unhandled ${node.type} (${(0, unified_latex_util_print_raw_1.printRaw)(node)})`, input: (0, unified_latex_util_print_raw_1.printRaw)(node) });
                break;
        }
        return tex;
    }
    wrap(text, tag, wrap = true) {
        if (!text || !wrap)
            return text || '';
        return `\x0E${tag}\x0F${text}\x0E/${tag}\x0F`;
    }
    registercommand(node) {
        const types = (nodes) => nodes.map(n => n.type).join('.');
        const group = (arg, kind) => {
            if (!arg)
                throw new Error(`missing ${kind} for ${(0, unified_latex_util_print_raw_1.printRaw)(node)} @ ${JSON.stringify(node.position)}`);
            if (types(arg.content) !== 'group')
                throw new Error(`Malformed ${kind} for ${(0, unified_latex_util_print_raw_1.printRaw)(node)} @ ${JSON.stringify(node.position)}`);
            return arg.content[0].content;
        };
        if (!node.args)
            throw new Error(`No arguments for ${(0, unified_latex_util_print_raw_1.printRaw)(node)} @ ${JSON.stringify(node.position)}`);
        const namearg = group(node.args[0], 'name');
        if (types(namearg) !== 'macro')
            throw new Error(`Unexpected name for ${(0, unified_latex_util_print_raw_1.printRaw)(node)} @ ${JSON.stringify(node.position)}`);
        this.newcommands[namearg[0].content] = node.args[1];
        return '';
    }
    subp(text, macro) {
        let subp = '';
        for (let char of text) {
            char = unicode2latex_1.latex2unicode[`${macro}{${char}}`];
            if (char) {
                subp += char;
            }
            else {
                const tag = { _: 'sub', '^': 'sup' }[macro];
                return `\x0E${tag}\x0F${text}\x0E/${tag}\x0F`;
            }
        }
        return subp;
    }
    macro(node, context) {
        var _a, _b, _c, _d, _e, _f, _g;
        const text = latex2unicode((0, unified_latex_util_print_raw_1.printRaw)(node), node);
        if (text)
            return text;
        let url;
        let label;
        let arg;
        let resolved;
        switch (node.content) {
            case 'newcommand':
            case 'ProvideTextCommandDefault':
                return this.registercommand(node);
            // too complex to deal with these
            case 'raise':
            case 'accent':
            case 'def':
            case 'hss':
            case 'ifmmode':
            case 'makeatletter':
            case 'makeatother':
            case 'scriptscriptstyle':
            case 'setbox':
            case 'dimen':
            case 'advance':
                return '';
            case 'vphantom':
            case 'noopsort':
            case 'left':
            case 'right':
            case 'ensuremath':
            case 'wd':
            case 'ht':
                return '';
            case 'path':
                return ''; // until https://github.com/siefkenj/unified-latex/issues/94 is fixed
            case 'hspace':
            case 'hskip':
                if (node.args && node.args.length) {
                    if ((0, unified_latex_util_print_raw_1.printRaw)(node.args).match(/^[{]?0[a-z]*$/))
                        return '';
                    return ' ';
                }
                return '';
            case 'overline':
            case 'bar':
                return node.args.map(a => this.stringify(a, context)).join('').replace(/[a-z0-9]/ig, m => `${m}\u0305`);
            // accents dealt with by preprocessor
            case 'textup':
            case 'textsc':
            case 'textrm':
            case 'texttt':
            case 'mathrm':
            case 'mbox':
            case 'hbox':
            case 'rlap':
                return node.args.map(n => this.stringify(n, context)).join('');
            case 'href':
            case 'url':
                if (node.args) {
                    url = node.args[0];
                    label = node.args[node.content === 'url' ? 0 : 1];
                }
                return `<a href="${this.stringify(url, context)}">${this.stringify(label, context)}</a>`;
            case 'relax':
            case 'aftergroup':
            case 'ignorespaces':
            case 'em':
            case 'it':
            case 'tt':
            case 'sl':
                return '';
            case 'rm':
            case 'sc':
                return '';
            // bold/emph/smallcaps is handled in the wrapper
            case 'textbf':
            case 'mkbibbold':
            case 'textit':
            case 'emph':
            case 'mkbibemph':
                return this.stringify((_a = node.args) === null || _a === void 0 ? void 0 : _a[0], context);
            case 'textsuperscript':
                return this.subp(this.stringify((_b = node.args) === null || _b === void 0 ? void 0 : _b[0], context), '^');
            case 'textsubscript':
                return this.subp(this.stringify((_c = node.args) === null || _c === void 0 ? void 0 : _c[0], context), '_');
            case '_':
            case '^':
                switch (latexMode(node)) {
                    case 'math':
                        return this.subp(this.stringify((_d = node.args) === null || _d === void 0 ? void 0 : _d[0], context), node.content);
                    default:
                        return node.content;
                }
            case 'LaTeX':
                return this.wrap(`L${this.subp('A', '^')}T${this.subp('E', '_')}X`, 'ncx');
            case 'enquote':
            case 'mkbibquote':
                return this.wrap(this.stringify((_e = node.args) === null || _e === void 0 ? void 0 : _e[0], context), 'enquote');
            case '\\':
                return context.mode === 'richtext' ? open.br : ' ';
            case 'par':
                return context.mode === 'richtext' ? open.p : ' ';
            case 'item':
                return context.mode === 'richtext' ? open.li : ' ';
            case 'section':
            case 'subsection':
            case 'subsubsection':
            case 'subsubsubsection':
                return this.wrap(this.stringify((_f = node.args) === null || _f === void 0 ? void 0 : _f[0], context), `h${node.content.split('sub').length}`);
            case 'frac':
                arg = node.args.map(a => this.stringify(a, context));
                if (arg.length === 2 && (resolved = unicode2latex_1.latex2unicode[`\\frac${arg.map(a => `{${a}}`).join('')}`]))
                    return resolved;
                return arg.map((part, i) => this.subp(part, i ? '_' : '^')).join('\u2044');
            case 'chsf':
            case 'bibstring':
            case 'cite':
            case 'textcite':
            case 'citeauthor':
                // ncx protects but will be stripped later
                return this.wrap(this.stringify((_g = node.args) === null || _g === void 0 ? void 0 : _g[0], context), 'ncx', context.mode === 'title');
            default:
                if (this.newcommands[node.content])
                    return this.stringify(this.newcommands[node.content], context);
                return this.unsupported(node);
        }
    }
    what(node) {
        var _a;
        if (!node)
            return '';
        switch (node.type) {
            case 'macro': return `macro:${(_a = node._renderInfo.mode) !== null && _a !== void 0 ? _a : 'text'}:${node.content}`;
            case 'environment': return `env:${node.env}`;
            default: return node.type;
        }
    }
    environment(node, context) {
        while (node.content.length && this.what(node.content[0]).match(/^parbreak|whitespace|macro:text:par$/))
            node.content.shift();
        while (node.content.length && this.what(node.content[node.content.length - 1]).match(/^parbreak|whitespace|macro:text:par$/))
            node.content.pop();
        switch (node.env) {
            case 'quotation':
                return this.wrap(node.content.map(n => this.stringify(n, context)).join(''), 'blockquote', context.mode === 'richtext');
            case 'itemize':
                return this.wrap(node.content.map(n => this.stringify(n, context)).join(''), 'ul', context.mode === 'richtext');
            case 'em':
                return this.wrap(node.content.map(n => this.stringify(n, context)).join(''), 'i', context.mode === 'richtext');
            default:
                return this.unsupported(node);
        }
    }
    stringify(node, context) {
        let content = this.stringifyContent(node, context);
        if (content && node._renderInfo) {
            if (node._renderInfo.emph)
                content = `${open.i}${content}${close.i}`;
            if (node._renderInfo.bold)
                content = `${open.b}${content}${close.b}`;
            if (node._renderInfo.smallCaps)
                content = `${open.sc}${content}${close.sc}`;
            if (node._renderInfo.code)
                content = `${open.code}${content}${close.code}`;
            if (this.english && node._renderInfo.protectCase)
                content = `${open.nc}${content}${close.nc}`;
        }
        return content;
    }
    stringifyContent(node, context) {
        if (!node)
            return '';
        switch (node.type) {
            case 'root':
            case 'argument':
            case 'group':
            case 'inlinemath':
                return node.content.map(n => this.stringify(n, context)).join('');
            case 'string':
            case 'verbatim':
                return node.content;
            case 'macro':
                return this.macro(node, context);
            case 'parbreak':
                return context.mode === 'richtext' ? open.p : ' ';
            case 'whitespace':
                return node._renderInfo.mode === 'math' ? '' : ' ';
            case 'comment':
                return '';
            case 'environment':
                return this.environment(node, context);
            case 'verb':
                return node.content;
            default:
                return this.unsupported(node);
        }
    }
    protect(node) {
        if (node.type === 'inlinemath')
            return true;
        if (node.type !== 'group')
            return false;
        if (!node.content.length)
            return false;
        return (node.content[0].type !== 'macro');
    }
    mode(field) {
        if (this.options.verbatimFields && this.options.verbatimFields.find(name => typeof name === 'string' ? (name === field) : field.match(name)))
            return 'verbatim';
        let mode = 'literal';
        for (const [selected, fields] of Object.entries(this.fieldMode)) {
            if (fields.find(match => typeof match === 'string' ? field === match : field.match(match)))
                mode = selected;
        }
        return mode;
    }
    restoreMarkup(s) {
        if (!s.includes('\x0E'))
            return s;
        const restored = [s.replace(/\x0E\/?ncx\x0F/ig, '')];
        while (restored[0] !== restored[1]) {
            restored.unshift(restored[0].replace(collapsable, '$2'));
        }
        return restored[0]
            .replace(/(\x0Ep\x0F\s*){2,}/ig, '\x0Ep\x0F')
            .replace(/\s*(\x0E\/p\x0F){2,}/ig, '\x0E/p\x0F')
            .replace(/\x0Eenquote\x0F/ig, '\u201C').replace(/\x0E\/enquote\x0F/ig, '\u201D')
            .replace(/\x0Esc\x0F/ig, '<span style="font-variant:small-caps;">').replace(/\x0E\/sc\x0F/ig, '</span>')
            .replace(/\x0Enc\x0F/ig, '<span class="nocase">').replace(/\x0E\/nc\x0F/ig, '</span>')
            .replace(/\x0E/ig, '<').replace(/\x0F/ig, '>');
    }
    stringField(field, value, mode, guessSC) {
        if (field === 'crossref')
            return value;
        if (FieldAction.parseInt.includes(field) && value.trim().match(/^-?\d+$/))
            return `${parseInt(value)}`;
        if (this.english && mode === 'title') {
            value = (0, sentence_case_1.toSentenceCase)(value, {
                preserveQuoted: this.options.sentenceCase && this.options.sentenceCase.preserveQuoted,
                subSentenceCapitalization: this.options.sentenceCase && this.options.sentenceCase.subSentence,
                markup: /\x0E\/?([a-z]+)\x0F/ig,
                nocase: /\x0E(ncx?)\x0F.*?\x0E\/\1\x0F/ig,
                guess: guessSC,
            });
            let cancel = (_match, stripped) => stripped;
            switch (this.options.caseProtection) {
                case 'strict':
                    cancel = (match, _stripped) => match;
                    break;
                case 'as-needed':
                    cancel = (match, stripped) => {
                        const words = (0, tokenizer_1.tokenize)(stripped, /\x0E\/?([a-z]+)\x0F/ig);
                        return words.find(w => w.shape.match(/^(?!.*X).*x.*$/)) ? match : this.wrap(stripped, 'ncx');
                    };
                    break;
            }
            return value.replace(/\x0Enc\x0F(.*?)\x0E\/nc\x0F/ig, cancel);
        }
        return value;
    }
    commaSeparatedCreator(ast) {
        var _a;
        const result = {
            parts: [],
        };
        if (!ast.content.find(node => node.type === 'string' && node.content === ','))
            return result;
        result.parts = this.split(ast, /^,$/, /(&)/);
        result.extended = {};
        for (const part of result.parts) {
            const start = ((_a = part.content[0]) === null || _a === void 0 ? void 0 : _a.type) === 'whitespace' ? 1 : 0;
            let signature = part.content
                .slice(start, start + 4)
                .map((node, i) => node._renderInfo.mode === 'text' && node.type === 'string' ? node.content.replace(i % 2 ? /[^=-]/g : /[^a-z]/gi, '.') : '.')
                .join('');
            if (signature.match(/^[a-z]+(-[a-z]+)?=/i)) {
                signature = signature.replace(/=.*/, '').toLowerCase();
                result.extended[signature] = { type: 'root', content: part.content.slice(signature.includes('-') ? start + 4 : start + 2) };
            }
            else {
                delete result.extended;
                break;
            }
        }
        return result;
    }
    field(entry, field, value) {
        const mode = entry.mode[field] = this.mode(field);
        const caseProtection = {
            present: false,
            intuitive: 0, // a lot of people don't realise `some text \textit{in italics}` will protect 'in italics'
        };
        const ast = unified_latex_util_pegjs_1.LatexPegParser.parse(value);
        if (this.options.removeOuterBraces.includes(field) && ast.content.length === 1 && ast.content[0].type === 'group') {
            ast.content = ast.content[0].content;
        }
        if (mode === 'verbatim') { // &^%@#&^%@# idiots wrapping verbatim fields
            entry.fields[field] = (0, unified_latex_util_print_raw_1.printRaw)(ast);
            return;
        }
        if (this.english && mode === 'title') {
            let root = [...ast.content];
            while (root.length) {
                const node = root.shift();
                // only root groups offer case protecten -- but it may be as an macro arg, so mark here before gobbling
                if (this.protect(node))
                    node._renderInfo = { root: true };
                // environments are considered root when at root
                if (node.type === 'environment')
                    root = [...root, ...node.content];
            }
        }
        // pass 0 -- register parse mode
        (0, unified_latex_util_visit_1.visit)(ast, (node, info) => {
            if (!node._renderInfo)
                node._renderInfo = {};
            node._renderInfo.mode = info.context.inMathMode ? 'math' : 'text';
            // if (info.context.inMathMode || info.context.hasMathModeAncestor) return
            if (mode === 'title' && node.type === 'inlinemath' && !info.parents.find(p => p._renderInfo.protectCase))
                node._renderInfo.protectCase = true;
            if (!info.context.inMathMode) {
                if (mode === 'title' && node._renderInfo.root && (node.type !== 'group' || node.content[0].type !== 'macro')) {
                    node._renderInfo.protectCase = true;
                    if (node.type === 'group') {
                        caseProtection.present = true;
                        caseProtection.intuitive += 1;
                    }
                }
                if (node.type === 'macro' && typeof node.escapeToken !== 'string')
                    node.escapeToken = '\\';
                if (node.type === 'environment' && node.env === 'em')
                    node._renderInfo.emph = true;
            }
        });
        if (this.options.raw) {
            switch (mode) {
                case 'creatorlist':
                    entry.fields[field] = this.split(ast, /^and$/i, /(^& | & | &$)/)
                        .map(cr => {
                        const { parts, extended } = this.commaSeparatedCreator(cr);
                        if (parts.length === 2 && !extended) {
                            return this.trimCreator({ lastName: (0, unified_latex_util_print_raw_1.printRaw)(parts[0]), firstName: (0, unified_latex_util_print_raw_1.printRaw)(parts[1]) });
                        }
                        if (!parts.length) {
                            const nameparts = this.split(ast, /^$/, /( )/);
                            if (nameparts.length === 2) {
                                return this.trimCreator({
                                    lastName: (0, unified_latex_util_print_raw_1.printRaw)(nameparts[1]),
                                    firstName: (0, unified_latex_util_print_raw_1.printRaw)(nameparts[0]),
                                });
                            }
                        }
                        return { name: (0, unified_latex_util_print_raw_1.printRaw)(cr) };
                    });
                    return;
                case 'literallist':
                    entry.fields[field] = this.split(ast, /^and$/i, /(^& | & | &$)/)
                        .map(elt => (0, unified_latex_util_print_raw_1.printRaw)(elt)); // pacify typescript
                    return;
                default:
                    entry.fields[field] = (0, unified_latex_util_print_raw_1.printRaw)(ast);
                    return;
            }
        }
        // pass 1 -- mark & normalize
        (0, unified_latex_util_visit_1.visit)(ast, (nodes, info) => {
            var _a;
            let node;
            const compacted = [];
            let inif = 0;
            while (nodes.length) {
                if (node = this.ligature(nodes)) {
                    compacted.push(node);
                    continue;
                }
                node = nodes.shift();
                if (node.type === 'macro' && node.content === 'ifdefined') {
                    inif += 1;
                    continue;
                }
                else if (node.type === 'macro' && node.content === 'else') {
                    continue;
                }
                else if (node.type === 'macro' && node.content === 'fi') {
                    inif = Math.max(inif - 1, 0);
                    continue;
                }
                else if (inif) {
                    continue;
                }
                const nargs = node.type === 'macro'
                    ? narguments[node.content] || narguments[`${info.context.inMathMode ? 'math' : 'text'}\t${node.content}`]
                    : 0;
                if (node.type === 'macro' && nargs) {
                    node.args = Array(nargs).fill(undefined).map(_i => this.argument(nodes, node)).filter(arg => arg);
                    if (node.content.match(/^(url|href)$/) && node.args.length) {
                        let url = node.args[0].content;
                        if (url.length === 1 && url[0].type === 'group')
                            url = url[0].content;
                        node.args[0] = this.wraparg({ type: 'string', content: (0, unified_latex_util_print_raw_1.printRaw)(url), _renderInfo: { mode: url[0]._renderInfo.mode } }, node);
                    }
                    caseProtection.intuitive -= node.args.filter(arg => arg.content[0].type === 'group' && arg.content[0]._renderInfo.protectCase).length;
                }
                else if (node.type === 'macro' && node.content.match(/^[a-z]+$/i) && ((_a = nodes[0]) === null || _a === void 0 ? void 0 : _a.type) === 'whitespace') {
                    nodes.shift();
                }
                compacted.push(node);
            }
            if (!info.context.inMathMode) {
                // feed-forward inline macros
                for (const [macro, markup] of Object.entries({ em: 'emph', it: 'emph', sl: 'emph', bf: 'bold', sc: 'smallCaps', tt: 'code' })) {
                    if (info.parents.find(p => p._renderInfo[markup]))
                        continue;
                    compacted.forEach((markup_node, i) => {
                        if (markup_node.type === 'macro' && markup_node.content === macro) {
                            compacted.slice(i + 1).forEach(n => n._renderInfo[markup] = true);
                        }
                    });
                }
            }
            nodes.push(...compacted);
        }, { test: Array.isArray, includeArrays: true });
        (0, unified_latex_util_replace_1.replaceNode)(ast, (node, _info) => {
            if (node.type !== 'macro')
                return;
            if (node.escapeToken && unicode2latex_1.combining.tounicode[node.content]) {
                let arg;
                // no args, args of zero length, or first arg has no content
                if (!node.args || node.args.length === 0 || node.args[0].content.length === 0) {
                    arg = { type: 'string', content: ' ', _renderInfo: {} };
                }
                else if (node.args.length !== 1 || node.args[0].content.length !== 1) {
                    return;
                }
                else {
                    arg = node.args[0].content[0];
                }
                if (arg.type === 'group') {
                    switch (arg.content.length) {
                        case 0:
                            arg = { type: 'string', content: ' ', _renderInfo: {} };
                            break;
                        case 1:
                            arg = arg.content[0];
                            break;
                        default:
                            return;
                    }
                }
                switch (arg.type) {
                    case 'verbatim':
                    case 'string':
                        return { type: 'string', content: `${arg.content}${unicode2latex_1.combining.tounicode[node.content]}`, _renderInfo: {} };
                    default:
                        return;
                }
            }
            let latex = `${node.escapeToken}${node.content}`;
            latex += (node.args || []).map(arg => (0, unified_latex_util_print_raw_1.printRaw)(this.argtogroup(arg))).join('');
            if (latex in unicode2latex_1.latex2unicode)
                return { type: 'string', content: latex2unicode(latex, node), _renderInfo: {} };
            // return null to delete
        });
        switch (mode) {
            case 'creatorlist':
                entry.fields[field] = this.split(ast, /^and$/i, /(^& | & | &$)/)
                    .map(cr => this.parseCreator(cr))
                    .filter(cr => Object.keys(cr).length); // pacify typescript
                break;
            case 'literallist':
                entry.fields[field] = this.split(ast, /^and$/i, /(^& | & | &$)/)
                    .map(elt => this.stringify(elt, { mode: 'literal' }).trim()); // pacify typescript
                break;
            default:
                entry.fields[field] = this.stringField(field, this.stringify(ast, { mode }), mode, this.options.sentenceCase && this.options.sentenceCase.guess // && (!caseProtection.present || caseProtection.intuitive > 0)
                );
                break;
        }
        // recursively restores markup in string content. 'as string' is just here to pacify typescript
        entry.fields[field] = JSON.parse(JSON.stringify(entry.fields[field], (k, v) => (typeof v === 'string' ? this.restoreMarkup(v) : v)));
    }
    reset(options = {}) {
        var _a;
        if (options.sentenceCase === false) {
            options = Object.assign(Object.assign({}, options), { english: false, sentenceCase: {
                    guess: false,
                    subSentence: false,
                    preserveQuoted: false,
                } });
        }
        this.options = (0, merge_1.merge)(options, {
            caseProtection: 'as-needed',
            applyCrossRef: (_a = options.applyCrossRef) !== null && _a !== void 0 ? _a : true,
            fieldMode: {},
            english: exports.English,
            sentenceCase: {
                guess: true,
                preserveQuoted: true,
            },
        });
        if (this.options.caseProtection === true)
            this.options.caseProtection = 'as-needed';
        if (this.options.verbatimFields)
            this.options.verbatimFields = this.options.verbatimFields.map(f => typeof f === 'string' ? f.toLowerCase() : new RegExp(f.source, f.flags + (f.flags.includes('i') ? '' : 'i')));
        if (typeof this.options.english === 'boolean')
            this.options.english = this.options.english ? exports.English : [];
        this.options.english = this.options.english.map(langid => langid.toLowerCase());
        this.fieldMode = Object.entries(exports.FieldMode).reduce((acc, [mode, test]) => {
            const strings = test.filter(fieldname_or_regex => typeof fieldname_or_regex === 'string' && !this.options.fieldMode[fieldname_or_regex]);
            const regexes = test.filter(fieldname_or_regex => typeof fieldname_or_regex !== 'string');
            acc[mode] = [...strings, ...regexes];
            return acc;
        }, {});
        for (const [field, mode] of Object.entries(this.options.fieldMode)) {
            this.fieldMode[mode].unshift(field);
        }
        if (!this.options.removeOuterBraces) {
            this.options.removeOuterBraces = [
                ...FieldAction.removeOuterBraces,
                ...this.fieldMode.title,
                ...this.fieldMode.verbatim,
            ].filter(field => typeof field === 'string');
        }
        this.fallback = options.unsupported === 'ignore' ? ((_node, _tex) => '') : options.unsupported;
        this.bib = {
            errors: [],
            entries: [],
            comments: [],
            strings: {},
            preamble: [],
            jabref: null,
        };
    }
    reparse(verbatim) {
        let langid = (verbatim.fields.langid || verbatim.fields.hyphenation || '').toLowerCase();
        if (!langid && this.options.languageAsLangid && verbatim.fields.language)
            langid = verbatim.fields.language.toLowerCase();
        this.english = this.options.english.includes(langid);
        const entry = this.current = {
            type: verbatim.type,
            key: verbatim.key,
            fields: {},
            mode: {},
            input: verbatim.input,
        };
        let keywords = []; // OMG #783
        try {
            for (let [field, value] of Object.entries(verbatim.fields)) {
                if (!value.trim())
                    continue;
                /*
                if (this.options.raw && !this.options.removeOuterBraces.includes(field)) {
                  entry.fields[field] = value.trim()
                  entry.mode[field] = 'verbatim'
                  continue
                }
                */
                if (field.match(/^keywords([+]duplicate-\d+)?$/))
                    field = 'keywords'; // #873
                this.field(entry, field, value);
                if (field === 'keywords') { // #873
                    keywords = [...keywords, ...entry.fields.keywords.split(/\s*[,;]\s*/)].map((k) => k.trim()).filter(k => k);
                    delete entry.fields.keywords;
                }
                if (!this.options.raw && typeof entry.fields[field] === 'string') {
                    entry.fields[field] = entry.fields[field].trim();
                    if (field === 'month')
                        entry.fields[field] = Month[entry.fields[field].toLowerCase()] || entry.fields[field];
                }
            }
            if (keywords.length) {
                entry.fields.keywords = [...(new Set(keywords))].sort((a, b) => a.toLowerCase().localeCompare(b.toLowerCase()));
                entry.mode.keywords = 'verbatimlist';
            }
            this.bib.entries.push(entry);
        }
        catch (err) {
            this.bib.errors.push({ error: `${err.message}\n${entry.input}`, input: entry.input });
        }
    }
    content(tex) {
        const entry = { key: '', type: '', fields: {}, mode: {}, input: tex };
        const english = this.english;
        this.english = false;
        this.field(entry, 'tex', tex);
        this.english = english;
        return entry.fields.tex;
    }
    prep(base) {
        for (const preamble of base.preambles) {
            try {
                this.content(preamble);
            }
            catch (_a) {
            }
        }
        for (const [k, v] of Object.entries(base.strings)) {
            this.bib.strings[k] = this.content(v);
        }
    }
    finalize(base) {
        var _a;
        if (this.options.applyCrossRef) {
            const entries = {};
            for (const entry of this.bib.entries) {
                if (entry.key)
                    entries[entry.key.toUpperCase()] = entry;
            }
            const order = [];
            for (const entry of this.bib.entries) {
                if (!entry.key || typeof entry.fields.crossref !== 'string')
                    continue;
                const crossref = entry.fields.crossref.toUpperCase();
                if (!entries[crossref])
                    continue;
                const key = entry.key.toUpperCase();
                if (!order.includes(crossref))
                    order.unshift(crossref);
                if (!order.includes(key))
                    order.push(key);
            }
            const add = (obj, kind, field) => {
                obj[kind] = [...(new Set([...obj[kind], field]))].sort();
            };
            for (const key of order) {
                const child = entries[key.toUpperCase()];
                const parent = entries[(_a = child.fields.crossref) === null || _a === void 0 ? void 0 : _a.toUpperCase()];
                if (!parent)
                    continue;
                child.crossref = child.crossref || { donated: [], inherited: [] };
                parent.crossref = parent.crossref || { donated: [], inherited: [] };
                for (const mappings of [crossref_json_1.default[child.type], crossref_json_1.default['*']].filter(m => m)) {
                    for (const mapping of [mappings[parent.type], mappings['*']].filter(m => m)) {
                        for (const [childfield, parentfield] of Object.entries(mapping)) {
                            if (!child.fields[childfield] && parent.fields[parentfield]) {
                                child.fields[childfield] = parent.fields[parentfield];
                                add(child.crossref, 'inherited', childfield);
                                add(parent.crossref, 'donated', parentfield);
                            }
                        }
                        for (const field of (fields_json_1.default[child.type] || [])) {
                            if (FieldAction.noCrossRef.includes(field))
                                continue;
                            if (!child.fields[field] && parent.fields[field]) {
                                child.fields[field] = parent.fields[field];
                                add(child.crossref, 'inherited', field);
                                add(parent.crossref, 'donated', field);
                            }
                        }
                    }
                }
            }
            for (const entry of this.bib.entries) {
                if (entry.crossref && !entry.crossref.donated.length && !entry.crossref.inherited.length)
                    delete entry.crossref;
            }
        }
        const { comments, jabref } = JabRef.parse(base.comments);
        this.bib.comments = comments;
        this.bib.jabref = jabref;
        this.bib.preamble = base.preambles;
        this.bib.errors = [...base.errors, ...this.bib.errors];
    }
    parse(input, options = {}) {
        this.reset(options);
        const base = bibtex.parse(input, { strings: options.strings });
        this.prep(base);
        for (const entry of base.entries) {
            this.reparse(entry);
        }
        this.finalize(base);
        return this.bib;
    }
    async parseAsync(input, options = {}) {
        this.reset(options);
        const base = await bibtex.promises.parse(input, { strings: options.strings });
        this.prep(base);
        let n = 1;
        for (const entry of base.entries) {
            this.reparse(entry);
            if ((n++ % 1000) === 0)
                await (0, yield_1.playnice)();
        }
        this.finalize(base);
        return this.bib;
    }
}
function parse(input, options = {}) {
    const parser = new BibTeXParser;
    return parser.parse(input, options);
}
async function parseAsync(input, options = {}) {
    const parser = new BibTeXParser;
    return await parser.parseAsync(input, options);
}
//# sourceMappingURL=index.js.map