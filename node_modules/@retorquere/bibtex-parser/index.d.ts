import { Node } from '@unified-latex/unified-latex-types';
import * as bibtex from './verbatim';
import * as JabRef from './jabref';
export { JabRefMetadata } from './jabref';
export { ParseError } from './verbatim';
export { toSentenceCase } from './sentence-case';
export { tokenize, Token } from './tokenizer';
type CreatorFields = {
    author?: Creator[];
    bookauthor?: Creator[];
    collaborator?: Creator[];
    commentator?: Creator[];
    director?: Creator[];
    editor?: Creator[];
    editora?: Creator[];
    editorb?: Creator[];
    editors?: Creator[];
    holder?: Creator[];
    scriptwriter?: Creator[];
    translator?: Creator[];
};
type ArrayFields = {
    keywords?: string[];
    institution?: string[];
    publisher?: string[];
    origpublisher?: string[];
    organization?: string[];
    location?: string[];
    origlocation?: string[];
};
type TypedFields = CreatorFields & ArrayFields;
type Fields = TypedFields & Omit<Record<string, string>, keyof TypedFields>;
export type Entry = {
    type: string;
    key: string;
    fields: Fields;
    mode: Record<string, ParseMode>;
    crossref?: {
        inherited: string[];
        donated: string[];
    };
    input: string;
};
export interface Library {
    /**
     * errors found while parsing
     */
    errors: bibtex.ParseError[];
    /**
     * entries in the order in which they are found, omitting those which could not be parsed.
     */
    entries: Entry[];
    /**
     * `@comment`s found in the bibtex file.
     */
    comments: string[];
    /**
     * `@string`s found in the bibtex file.
     */
    strings: Record<string, string>;
    /**
     * `@preamble` declarations found in the bibtex file
     */
    preamble: string[];
    /**
     * jabref metadata (such as groups information) found in the bibtex file
     */
    jabref: JabRef.JabRefMetadata;
}
export interface Options {
    /**
     * Bib(La)TeX handles entries that are in English differently from emtries in other languages. For English-like entries,
     * it expects titles in title-case. Words within braces are recognized as "case-protected" and their original casing is preserved during
     * rendering. For non-English entries, the casing as entered in the entries is rendered as entered. Other reference managers, such as
     * Zotero, expect all titles to be in sentence-case. In this parser you can specify which `langid` values mark an entry to be English so
     * that it can convert those titles to sentence-case, and to carry over case-protection. If no `langid` is present an entry is
     * assumed to be English by bib(la)tex, and the parser follows that convention. Note that sentence-casing uses heuristics and
     * does not employ any kind of natural language processing, so you should always inspect the results. If you offer your own list
     * of english-langids here, do not forget to include the empty string, stands for "`langid` absent". Default languages to sentenceCase
     * are the empty string, plus:
     *
     * - american
     * - british
     * - canadian
     * - english
     * - australian
     * - newzealand
     * - usenglish
     * - ukenglish
     * - en
     * - eng
     * - en-au
     * - en-bz
     * - en-ca
     * - en-cb
     * - en-gb
     * - en-ie
     * - en-jm
     * - en-nz
     * - en-ph
     * - en-tt
     * - en-us
     * - en-za
     * - en-zw
     *
     * If you pass an empty array, or `false`, no sentence casing will be applied (even when there's no language field).
     */
    english?: string[] | boolean;
    /**
      * By default, `langid` and `hyphenation` are used to determine whether an entry is English, but some sources (ab)use the `language` field
      * for this. If you turn on this option, this field will also be taken into account as a source for `langid`.
      */
    languageAsLangid?: boolean;
    sentenceCase?: false | {
        /**
         * Some bibtex files will have English titles in sentence case, or all-uppercase. If this is on, and there is a field that would
         * normally have sentence-casing applied in which there are all-lowercase words that are not prepositions (where `X` is either
         * lower or upper) than mixed-case, it is assumed that you want them this way, and no sentence-casing will be applied to that field
         */
        guess?: boolean;
        /**
         * Retain Capitalised words in sub-sentences after colons. Given the input title "Structured Interviewing For OCB: Construct Validity,
         * Faking, And The Effects Of Question Type":
         * - when `true`, sentence-cases to "Structured interviewing for OCB: Construct validity, faking, and the effects of question type"
         * - when `false`, sentence-cases to "Structured interviewing for OCB: construct validity, faking, and the effects of question type"
         */
        subSentence?: boolean;
        /**
         * If you have sentence-casing on, you can independently choose whether quoted titles within a title are preserved as-is (true)
         * or also sentence-cased (false).
         */
        preserveQuoted?: boolean;
    };
    /**
     * translate braced parts of English-entry titles into a case-protected counterpart; Default == true == as-needed.
     * In as-needed mode the parser will assume that words that have capitals in them imply "nocase" behavior in the consuming application. If you don't want this, turn this option on, and you'll get
     * case protection exactly as the input has it
     */
    caseProtection?: 'as-needed' | 'strict' | boolean;
    /**
     * By default, when a TeX command is encountered which the parser does not know about, the parser will throw an error. You can pass a function here to return the appropriate text output for the command.
     */
    unsupported?: 'ignore' | unsupportedHandler;
    /**
     * Some fields such as `url` are parsed in what is called "verbatim mode" where pretty much everything except braces is treated as regular text, not TeX commands. You can change the default list here if you want,
     * for example to help parse Mendeley `file` fields, which against spec are not in verbatim mode.
     */
    verbatimFields?: (string | RegExp)[];
    /**
     * In the past many bibtex entries would just always wrap a field in double braces, likely because whomever was writing them couldn't figure out the case meddling rules (and who could
     * blame them). Fields listed here will either have one outer layer of braces treated as case-preserve, or have the outer braced be ignored completely, if this is detected.
     */
    removeOuterBraces?: string[];
    /**
     * Specify parsing mode for specific fields
     */
    fieldMode?: Record<string, ParseMode>;
    /**
     * If this flag is set entries will be returned without conversion of LaTeX to unicode equivalents.
     */
    raw?: boolean;
    /**
     * You can pass in an existing `@string` dictionary
     */
    strings?: Record<string, string> | string;
    /**
     * Apply crossref inheritance
     */
    applyCrossRef?: boolean;
}
export interface Creator {
    name?: string;
    lastName?: string;
    firstName?: string;
    prefix?: string;
    suffix?: string;
    initial?: string;
    useprefix?: boolean;
    juniorcomma?: boolean;
}
export declare const FieldMode: {
    creatorlist: string[];
    title: string[];
    verbatim: (string | RegExp)[];
    richtext: string[];
    literallist: string[];
};
type ParseMode = keyof typeof FieldMode | 'literal' | 'verbatimlist';
export declare const English: string[];
type unsupportedHandler = (node: Node, tex: string, entry: Entry) => string;
export declare function parse(input: string, options?: Options): Library;
export declare function parseAsync(input: string, options?: Options): Promise<Library>;
//# sourceMappingURL=index.d.ts.map