"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parse = parse;
function decode(s, sep = ';') {
    s = s.replace(/\r?\n/g, '');
    let pos = 0;
    const records = [''];
    while (pos < s.length) {
        switch (s[pos]) {
            case '\\':
                pos++;
                records[0] += s[pos];
                break;
            case sep:
                records.unshift('');
                break;
            default:
                records[0] += s[pos];
        }
        pos++;
    }
    return records.reverse().filter(record => record);
}
/**
 * Import the JabRef groups from the `@string` comments in which they were stored. You would typically pass the comments parsed by [[bibtex.parse]] in here.
 *
 * JabRef knows several group types, and this parser parses most, but not all of them:
 *
 * * independent group: the keys listed in the group are the entries that are considered to belong to it
 * * intersection: the keys listed in the group are considered to belong to the group if they're also in the parent group
 * * union: the keys listed in the group are considered to belong to the group, and also the keys that are in the parent group
 * * query: not supported by this parser
 */
function parse(comments) {
    const result = {
        root: [],
        groups: {},
    };
    const levels = [];
    const decoded = {
        fileDirectory: null,
        groupsversion: null,
        groupstree: null,
        grouping: null,
        databaseType: null,
    };
    comments = comments.filter(comment => {
        const m = comment.match(/^jabref-meta:\s*([^:]+):([\s\S]*)/); // use \s\S because mozilla doesn't understand /s
        if (m) {
            decoded[m[1]] = decode(m[2]);
            return false;
        }
        return true;
    });
    if (decoded.groupsversion)
        result.groupsversion = parseInt(decoded.groupsversion[0].trim()) || decoded.groupsversion[0]; // eslint-disable-line @typescript-eslint/no-unsafe-argument
    if (decoded.fileDirectory)
        result.fileDirectory = decoded.fileDirectory[0];
    if (decoded.databaseType)
        result.databaseType = decoded.databaseType[0];
    for (const tree of ['groupstree', 'grouping']) {
        if (!decoded[tree])
            continue;
        for (const encoded of decoded[tree]) {
            const fields = decode(encoded);
            const level_type_name = decode(fields.shift(), ':');
            const m = /^([0-9]+) (.+)/.exec(level_type_name[0]);
            if (!m)
                break;
            const level = parseInt(m[1]);
            const type = m[2]; // test for StaticGroup?
            if (type === 'AllEntriesGroup')
                continue; // root
            const name = level_type_name[1];
            const intersection = decode(fields.shift())[0];
            const keys = tree === 'grouping' ? [] : fields.map(field => decode(field)[0]);
            const group = {
                name,
                entries: keys,
                groups: [],
            };
            result.groups[name] = result.groups[name] || group;
            if (levels.length < level) {
                levels.push(group);
            }
            else {
                levels[level - 1] = group;
            }
            if (level === 1) {
                result.root.push(group);
            }
            else {
                const parent = levels[level - 2];
                switch (intersection) {
                    case '0': // independent
                        break;
                    case '1': // intersect
                        group.entries = group.entries.filter(key => parent.entries.includes(key));
                        break;
                    case '2': // union
                        group.entries = group.entries.concat(parent.entries.filter(key => !group.entries.includes(key)));
                        break;
                }
                levels[level - 2].groups.push(group);
            }
        }
    }
    return { comments, jabref: result };
}
//# sourceMappingURL=jabref.js.map